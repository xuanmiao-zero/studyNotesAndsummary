### 引言
　　找出一个字符串中的所有数字:
```str.match(/\d+/g);```
### 概念
　　正则是一种模糊匹配字符串的规则
### 创建
* 简写:　//
* 全写：new RegExp(字符串||正则,字符串)。
    * 第一个参数：匹配规则，第二个参数：修饰符。
### 规则
*   转义符
    *   一个任意字符
    *	\d 一个数字
    *	\D 一个非数字
    *	\w 一个字母或数字
    *   特殊字符 * . ? + $ ^ [ ] ( ) { } | \ / 用'/'转义，
    * 匹配双字节字符(包括汉字在内)：[^\x00-\xff]
    * 匹配中文字符的正则表达式： [\u4e00-\u9fa5] [有事100，有酒罚我]
*   其他符号
    *	| 或
    *	[]表示选择范围，
        *   eg: [a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}1-20个字符的变量。
    *	^ 表示行的开头，^\d 表示必须以数字开头。
    *	如果^在中括号中，就是排除中括号中的内容。
    *	$表示行的结束，
        *   eg:\d$表示必须以数字结束
*	修饰符
    *	i 忽略大小写
    *	g 全局
    *	m 多行
*	量词
    *	\* 任意个字符（包括0）
    *	\+ 至少一个字符
    *	? 0或1个字符
    *	{n} n个字符
    *	{n,m} n-m个字符
*	子项　()　第ｉ个子项，对应回调函数第ｉ+1个参数。
### 特性
*	贪婪：+，*匹配时尽可能多个字符，后面加?可以让\d+采用非贪婪匹配
*	懒惰：只找一个。
    *	如果子项后有＋号匹配的是子项和+一块匹配到的字符串的最后一个字符
### 方法
*   reg.test(string) 查看正则是否匹配字符串，如果是返回true否则false
*	reg.exec(字符串); 返回一个数组，第一个数组元素时正则表达式匹配到的字符串，后面的数组元素表示匹配成功的子串。
    *   eg:	识别合法的时间。
```
regvar re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;
re.exec('19:05:30'); /*['19:05:30', '19', '05', '30']*/
```